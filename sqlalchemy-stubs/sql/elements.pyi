from typing import Any, Optional
from . import operators
from sqlalchemy import util
from .visitors import Visitable as Visitable
from .annotation import Annotated as Annotated
from .base import Executable as Executable, Immutable as Immutable

def collate(expression, collation): ...
def between(expr, lower_bound, upper_bound, symmetric: bool = ...): ...
def literal(value, type_: Optional[Any] = ...): ...
def outparam(key, type_: Optional[Any] = ...): ...
def not_(clause): ...

class ClauseElement(Visitable):
    __visit_name__: str = ...
    supports_execution: bool = ...
    bind: Any = ...
    is_selectable: bool = ...
    is_clause_element: bool = ...
    description: Any = ...
    def unique_params(self, *optionaldict, **kwargs): ...
    def params(self, *optionaldict, **kwargs): ...
    def compare(self, other, **kw): ...
    def get_children(self, **kwargs): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def compile(self, bind: Optional[Any] = ..., dialect: Optional[Any] = ..., **kw): ...
    def __and__(self, other): ...
    def __or__(self, other): ...
    def __invert__(self): ...
    def __bool__(self): ...
    __nonzero__: Any = ...

class ColumnElement(operators.ColumnOperators, ClauseElement):
    __visit_name__: str = ...
    primary_key: Any = ...
    foreign_keys: Any = ...
    key: Any = ...
    def self_group(self, against: Optional[Any] = ...): ...
    @property
    def type(self): ...
    def comparator(self): ...
    def __getattr__(self, key): ...
    def operate(self, op, *other, **kwargs): ...
    def reverse_operate(self, op, other, **kwargs): ...
    @property
    def expression(self): ...
    def base_columns(self): ...
    def proxy_set(self): ...
    def shares_lineage(self, othercolumn): ...
    def compare(self, other, **kw): ...
    def cast(self, type_): ...
    def label(self, name): ...
    def anon_label(self): ...

class BindParameter(ColumnElement):
    __visit_name__: str = ...
    key: Any = ...
    unique: Any = ...
    value: Any = ...
    callable: Any = ...
    isoutparam: Any = ...
    required: Any = ...
    type: Any = ...
    def __init__(self, key, value: Any = ..., type_: Optional[Any] = ..., unique: bool = ...,
                 required: Any = ..., quote: Optional[Any] = ..., callable_: Optional[Any] = ...,
                 isoutparam: bool = ..., _compared_to_operator: Optional[Any] = ...,
                 _compared_to_type: Optional[Any] = ...) -> None: ...
    @property
    def effective_value(self): ...
    def compare(self, other, **kw): ...

class TypeClause(ClauseElement):
    __visit_name__: str = ...
    type: Any = ...
    def __init__(self, type) -> None: ...

class TextClause(Executable, ClauseElement):
    __visit_name__: str = ...
    @property
    def selectable(self): ...
    key: Any = ...
    text: Any = ...
    def __init__(self, text, bind: Optional[Any] = ...) -> None: ...
    def bindparams(self, *binds, **names_to_values): ...
    def columns(self, *cols, **types): ...
    @property
    def type(self): ...
    @property
    def comparator(self): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def get_children(self, **kwargs): ...
    def compare(self, other): ...
    @classmethod
    def _create_text(cls, text, bind: Optional[Any] = ..., bindparams: Optional[Any] = ...,
                     typemap: Optional[Any] = ..., autocommit: Optional[Any] = ...) -> TextClause: ...

class Null(ColumnElement):
    __visit_name__: str = ...
    @property
    def type(self): ...
    def compare(self, other): ...
    @classmethod
    def _instance(cls) -> Null: ...

class False_(ColumnElement):
    __visit_name__: str = ...
    @property
    def type(self): ...
    def compare(self, other): ...
    @classmethod
    def _instance(cls) -> False_: ...

class True_(ColumnElement):
    __visit_name__: str = ...
    @property
    def type(self): ...
    def compare(self, other): ...
    @classmethod
    def _instance(cls) -> True_: ...

class ClauseList(ClauseElement):
    __visit_name__: str = ...
    operator: Any = ...
    group: Any = ...
    group_contents: Any = ...
    clauses: Any = ...
    def __init__(self, *clauses, **kwargs) -> None: ...
    def __iter__(self): ...
    def __len__(self): ...
    def append(self, clause): ...
    def get_children(self, **kwargs): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def compare(self, other, **kw): ...

class BooleanClauseList(ClauseList, ColumnElement):
    __visit_name__: str = ...
    def __init__(self, *arg, **kw) -> None: ...
    @classmethod
    def and_(cls, *clauses) -> BooleanClauseList: ...
    @classmethod
    def or_(cls, *clauses) -> BooleanClauseList: ...
    def self_group(self, against: Optional[Any] = ...): ...

and_ = BooleanClauseList.and_
or_ = BooleanClauseList.or_

class Tuple(ClauseList, ColumnElement):
    type: Any = ...
    def __init__(self, *clauses, **kw) -> None: ...

class Case(ColumnElement):
    __visit_name__: str = ...
    value: Any = ...
    type: Any = ...
    whens: Any = ...
    else_: Any = ...
    def __init__(self, whens, value: Optional[Any] = ..., else_: Optional[Any] = ...) -> None: ...
    def get_children(self, **kwargs): ...

def literal_column(text, type_: Optional[Any] = ...): ...

class Cast(ColumnElement):
    __visit_name__: str = ...
    type: Any = ...
    clause: Any = ...
    typeclause: Any = ...
    def __init__(self, expression, type_) -> None: ...
    def get_children(self, **kwargs): ...

class TypeCoerce(ColumnElement):
    __visit_name__: str = ...
    type: Any = ...
    clause: Any = ...
    def __init__(self, expression, type_) -> None: ...
    def get_children(self, **kwargs): ...
    @property
    def typed_expression(self): ...

class Extract(ColumnElement):
    __visit_name__: str = ...
    type: Any = ...
    field: Any = ...
    expr: Any = ...
    def __init__(self, field, expr, **kwargs) -> None: ...
    def get_children(self, **kwargs): ...

class UnaryExpression(ColumnElement):
    __visit_name__: str = ...
    operator: Any = ...
    modifier: Any = ...
    element: Any = ...
    type: Any = ...
    negate: Any = ...
    wraps_column_expression: Any = ...
    def __init__(self, element, operator: Optional[Any] = ..., modifier: Optional[Any] = ...,
                 type_: Optional[Any] = ..., negate: Optional[Any] = ...,
                 wraps_column_expression: bool = ...) -> None: ...
    def get_children(self, **kwargs): ...
    def compare(self, other, **kw): ...
    def self_group(self, against: Optional[Any] = ...): ...
    @classmethod
    def _create_nullsfirst(cls, column) -> UnaryExpression: ...
    @classmethod
    def _create_nullslast(cls, column) -> UnaryExpression: ...
    @classmethod
    def _create_desc(cls, column) -> UnaryExpression: ...
    @classmethod
    def _create_asc(cls, column) -> UnaryExpression: ...
    @classmethod
    def _create_distinct(cls, expr) -> UnaryExpression: ...

class CollectionAggregate(UnaryExpression):
    def operate(self, op, *other, **kwargs): ...
    def reverse_operate(self, op, other, **kwargs): ...
    @classmethod
    def _create_all(cls, expr: Any) -> CollectionAggregate: ...
    @classmethod
    def _create_any(cls, expr: Any) -> CollectionAggregate: ...

class AsBoolean(UnaryExpression):
    element: Any = ...
    type: Any = ...
    operator: Any = ...
    negate: Any = ...
    modifier: Any = ...
    wraps_column_expression: bool = ...
    def __init__(self, element, operator, negate) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...

class BinaryExpression(ColumnElement):
    __visit_name__: str = ...
    left: Any = ...
    right: Any = ...
    operator: Any = ...
    type: Any = ...
    negate: Any = ...
    modifiers: Any = ...
    def __init__(self, left, right, operator, type_: Optional[Any] = ..., negate: Optional[Any] = ...,
                 modifiers: Optional[Any] = ...) -> None: ...
    def __bool__(self): ...
    __nonzero__: Any = ...
    @property
    def is_comparison(self): ...
    def get_children(self, **kwargs): ...
    def compare(self, other, **kw): ...
    def self_group(self, against: Optional[Any] = ...): ...

class Slice(ColumnElement):
    __visit_name__: str = ...
    start: Any = ...
    stop: Any = ...
    step: Any = ...
    type: Any = ...
    def __init__(self, start, stop, step) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...

class IndexExpression(BinaryExpression): ...

class Grouping(ColumnElement):
    __visit_name__: str = ...
    element: Any = ...
    type: Any = ...
    def __init__(self, element) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...
    def get_children(self, **kwargs): ...
    def __getattr__(self, attr): ...
    def compare(self, other, **kw): ...

RANGE_UNBOUNDED: Any = ...
RANGE_CURRENT: Any = ...

class Over(ColumnElement):
    __visit_name__: str = ...
    order_by: Any = ...
    partition_by: Any = ...
    element: Any = ...
    range_: Any = ...
    rows: Any = ...
    def __init__(self, element, partition_by: Optional[Any] = ..., order_by: Optional[Any] = ...,
                 range_: Optional[Any] = ..., rows: Optional[Any] = ...) -> None: ...
    @property
    def func(self): ...
    @property
    def type(self): ...
    def get_children(self, **kwargs): ...

class WithinGroup(ColumnElement):
    __visit_name__: str = ...
    order_by: Any = ...
    element: Any = ...
    def __init__(self, element, *order_by) -> None: ...
    def over(self, partition_by: Optional[Any] = ..., order_by: Optional[Any] = ...): ...
    @property
    def type(self): ...
    def get_children(self, **kwargs): ...

class FunctionFilter(ColumnElement):
    __visit_name__: str = ...
    criterion: Any = ...
    func: Any = ...
    def __init__(self, func, *criterion) -> None: ...
    def filter(self, *criterion): ...
    def over(self, partition_by: Optional[Any] = ..., order_by: Optional[Any] = ...): ...
    @property
    def type(self): ...
    def get_children(self, **kwargs): ...

class Label(ColumnElement):
    __visit_name__: str = ...
    name: Any = ...
    key: Any = ...
    def __init__(self, name, element, type_: Optional[Any] = ...) -> None: ...
    def __reduce__(self): ...
    @property
    def type(self): ...
    @property
    def element(self): ...
    def self_group(self, against: Optional[Any] = ...): ...
    @property
    def primary_key(self): ...
    @property
    def foreign_keys(self): ...
    def get_children(self, **kwargs): ...

class ColumnClause(Immutable, ColumnElement):
    __visit_name__: str = ...
    onupdate: Any = ...
    default: Any = ...
    server_default: Any = ...
    server_onupdate: Any = ...
    key: Any = ...
    table: Any = ...
    type: Any = ...
    is_literal: Any = ...
    def __init__(self, text, type_: Optional[Any] = ..., is_literal: bool = ...,
                 _selectable: Optional[Any] = ...) -> None: ...
    @property
    def description(self): ...

class _IdentifiedClause(Executable, ClauseElement):
    __visit_name__: str = ...
    ident: Any = ...
    def __init__(self, ident) -> None: ...

class SavepointClause(_IdentifiedClause):
    __visit_name__: str = ...

class RollbackToSavepointClause(_IdentifiedClause):
    __visit_name__: str = ...

class ReleaseSavepointClause(_IdentifiedClause):
    __visit_name__: str = ...

class quoted_name(util.MemoizedSlots, util.text_type):
    quote: Any = ...
    def __new__(cls, value, quote): ...
    def __reduce__(self): ...

class _truncated_label(quoted_name):
    def __new__(cls, value, quote: Optional[Any] = ...): ...
    def __reduce__(self): ...
    def apply_map(self, map_): ...

class conv(_truncated_label): ...

class AnnotatedColumnElement(Annotated):
    def __init__(self, element, values) -> None: ...
    @property
    def name(self): ...
    @property
    def table(self): ...
    @property
    def key(self): ...
    @property
    def info(self): ...
    @property
    def anon_label(self): ...
